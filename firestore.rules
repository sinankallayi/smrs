rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {
    
    // =========================================================================
    // HELPER FUNCTIONS
    // =========================================================================
    
    function getUserData() {
      return get(/databases/$(database)/documents/users/$(request.auth.uid)).data;
    }

    function isSuperAdmin(userData) {
      return userData.role == 'superAdmin';
    }

    function isManagement(userData) {
      return userData.role == 'management';
    }

    function isHR(userData) {
      return userData.role == 'hr';
    }

    function isSectionHead(userData) {
      return userData.role == 'sectionHead';
    }

    function isStaff(userData) {
      return userData.role == 'staff';
    }

    // =========================================================================
    // COLLECTIONS
    // =========================================================================

    // USERS COLLECTION
    match /users/{userId} {
      // Users can read/update their own profile.
      allow update: if request.auth != null && request.auth.uid == userId;
      
      // DEBUG: Simplified rule to identify recursion issue.
      // If this works, the previous rules were definitely recursive.
      allow get: if request.auth != null;

      // Allow LIST (queries) for everyone to support EmployeeID login lookup
      allow list: if true;
      
      // Super Admin and HR are the primary user managers.
      allow write: if request.auth != null && (
        isSuperAdmin(getUserData()) || 
        (isHR(getUserData()) && request.resource.data.role == 'staff')
      );
    }

    // LEAVES COLLECTION
    match /leaves/{leaveId} {
      // Create: Staff can create their own requests
      allow create: if request.auth != null && 
                   request.resource.data.userId == request.auth.uid;
      
      // Read:
      // Temporarily relaxed to allow all authenticated users to read leaves.
      // Logic is handled client-side.
      allow read: if request.auth != null;
      
      // Update:
      // 1. Management can update (Approve/Reject).
      // 2. Section Heads can update leaves from their section (Forward/Reject/Finalize).
      // 3. Super Admin can update anything.
      allow update: if request.auth != null && (
        isManagement(getUserData()) ||
        isSuperAdmin(getUserData()) ||
        // Dynamic Role-Based Approval:
        // If the user's role (e.g. 'Kitchen') is in the list of current approvers for this leave request.
        (getUserData().role in resource.data.currentApproverRoles) ||
        // Fallback/Legacy for Section Heads (if user still has 'sectionHead' role)
        (isSectionHead(getUserData()) && resource.data.userSection == getUserData().section)
      );

      // Delete: Management and Super Admin
      allow delete: if request.auth != null && (isManagement(getUserData()) || isSuperAdmin(getUserData()));
    }

    // CONFIGURATIONS (Leave Flow, etc.)
    match /configurations/{configId} {
        allow read: if request.auth != null;
        allow write: if request.auth != null && isSuperAdmin(getUserData());
    }

    // SETTINGS COLLECTION (Roles & Sections)
    match /settings/{document} {
      allow read: if request.auth != null;
      allow write: if request.auth != null && isSuperAdmin(getUserData());
    }
  }
}
